---
title: 'Gerrymandering: Exploring the Data'
author: "An, Anderson, and Deck"
date: "4/4/2021"
output: pdf_document
---

We are interested in a more reasonable naming device to provide a better way to think about each map. 

For the gerrymandered maps we refer to them as $Gerry_i$ for $i \in \{A,B\}$ where $i$ identifies the player for whom the map is gerrymandered (Player A is advantaged in $Gerry_A$). That is, Map 1 will be $Gerry_B$ and Map 5 will be $Gerry_A$.

As the remaining maps are symmetric at the player level we reference $Sym_{d,z}$ for $d \in \{1,3\}$ and $z \in \{1,3\}$ where $d$ denotes the number of competitive districts and $z$ denotes the number of zones within each competitive district. That is, Map 2 will be $Sym_{1,1}$, Map 3 will be $Sym_{1,3}$, and Map 4 will be $Sym_{3,1}$.

For reference:

![]("Maps_Image")

Reading from left to right we have Gerry_B, Symm_1_1, Symm_1_3, Symm_3_1, and Gerry_A.

```{r setup, include=FALSE, warning=F, message=F}
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(ggplot2)
library(dplyr)

# read in all data files for sessions 1 through 8
for(i in 1:8) {
  x <- read_excel(paste("Cleaned_Raw_Session_0", i, ".xlsx", sep = "")) %>% dplyr::select(
    Session, Period, Subject, Player, partner, LType, Map_Selection = Map, EDG5:EW1, TE1:TE5, pEDG5:pEW1
  ) 
 nam <- paste("df", i, sep = "_")
 assign(nam, x)
}

# combine data vertically
df <- rbind(df_1, df_2, df_3, df_4, df_5, df_6, df_7, df_8)
# library(tidyr)
# long_df <- df %>% gather(District, Effort, EDG5:EW1)
df <- df %>% rename(Partner = partner,
  EDG_5 = EDG5, EDG_4 = EDG4, EDG_3 = EDG3, EDG_2 = EDG2, EDG_1 = EDG1,
  ELG_5 = ELG5, ELG_4 = ELG4, ELG_3 = ELG3, ELG_2 = ELG2, ELG_1 = ELG1,
  EW_5  = EW5, EW_4  = EW4, EW_3  = EW3, EW_2  = EW2, EW_1  = EW1,
  TE_5 = TE5, TE_4 = TE4, TE_3 = TE3, TE_2 = TE2, TE_1 = TE1,
  pEDG_5 = pEDG5, pEDG_4 = pEDG4, pEDG_3 = pEDG3, pEDG_2 = pEDG2, pEDG_1 = pEDG1,
  pELG_5 = pELG5, pELG_4 = pELG4, pELG_3 = pELG3, pELG_2 = pELG2, pELG_1 = pELG1,
  pEW_5  = pEW5, pEW_4  = pEW4, pEW_3  = pEW3, pEW_2  = pEW2, pEW_1  = pEW1
)
library(tidyr)
long_df <- df %>% dplyr::select(Session, Period, Subject, Player, Partner, LType, EDG_5:EW_1, pEDG_5:pEW_1) %>% gather(District, Effort, EDG_5:pEW_1)

# Orderly data with district, Map, and effort amount for each subject each period in each session

# No need to use long_df_map because already renamed them manually above
df_clean <- long_df %>% separate(District, c("District", "Map"))

# get some interesting tables
avg.bid.map.district <- df_clean %>% group_by(Player, Map, District) %>% summarise(avg.Effort = mean(as.numeric(Effort)))
avg.bid.by.session <- df_clean %>% group_by(Session) %>% summarise(avg.Effort = mean(as.numeric(Effort)))
avg.bid.session.map.district <- df_clean %>% group_by(Session, Map, District) %>% summarise(avg.Effort = mean(as.numeric(Effort)))
# recall: periods 15 - 24 are Stage 1, 25-27 are Stage 2, and 28 is Stage 3
avg.bid.by.period <- df_clean %>% group_by(Period, Map, District) %>% summarise(avg.Effort = mean(as.numeric(Effort)))

# Let's consider just the competitive districts
df_comp <- df_clean %>% subset(District == "EW" | (District==c("EDG","ELG") & Map == 4))
avg.bid.comp.dist <- df_comp %>% group_by(Map, District) %>% summarise(avg.Effort = mean(as.numeric(Effort)))
avg.bid.comp.session <- df_comp %>% group_by(Session) %>% summarise(avg.Effort = mean(as.numeric(Effort)))
avg.bid.comp.session.map.dist <- df_comp %>% group_by(Session, Map, District) %>% summarise(avg.Effort = mean(as.numeric(Effort)))

##
# install.packages("ggpubr")
library(ggpubr)
theme_set(theme_pubr())
```

\newpage

Note that in Gerry_A, Gerry_B, Symm_1_1, and Symm_1_3 the white district is the only competitive district in the sense that only the competition within the white district determines whether a subject wins that Map. The exception is Symm_3_1 in which it is logical to bid in any district as no district is guaranteed a victor.

Gerry_B


```{r, message=F, echo=F}
# Equilibrium effort: .25v
g1.1 <- ggplot(df, aes(x = EDG_1)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 0, linetype = "dashed") + xlim(0,80) +
  facet_wrap(~Player) + 
  ggtitle("Bids in Dark Grey: Gerry_B")
g1.2 <- ggplot(df, aes(x = ELG_1)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 0, linetype = "dashed") + xlim(0,80) +
  facet_wrap(~Player) + 
  ggtitle("Bids in Light Grey: Gerry_B")
g1.3 <- ggplot(df, aes(x = EW_1)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 20, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in White: Gerry_B")

figure <- ggarrange(g1.1, g1.2, g1.3,
                    labels = c("A", "B", "C"),
                    ncol = 2, nrow = 2)
figure
```

\newpage
  
$Symmetric_{1,1}$


```{r, message=F, echo=F}
# Equilibrium effort: .25v
g2.1 <- ggplot(df, aes(x = EDG_2)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 0, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in Dark Grey: Symm_1_1")
g2.2 <- ggplot(df, aes(x = ELG_2)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 0, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in Light Grey: Symm_1_1")
g2.3 <- ggplot(df, aes(x = EW_2)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 20, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in White: Symm_1_1")

figure.2 <- ggarrange(g2.1, g2.2, g2.3,
                    labels = c("A", "B", "C"),
                    ncol = 2, nrow = 2)
figure.2
```

\newpage

$Symmetric_{1,3}$


```{r, message=F, echo=F}
# Equilibrium effort: 3/8 v
g3.1 <- ggplot(df, aes(x = EDG_3)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 0, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in Dark Grey: Symm_1_3")
g3.2 <- ggplot(df, aes(x = ELG_3)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 0, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in Light Grey: Symm_1_3")
g3.3 <- ggplot(df, aes(x = EW_3)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 60, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in White: Symm_1_3")

figure.3 <- ggarrange(g3.1, g3.2, g3.3,
                    labels = c("A", "B", "C"),
                    ncol = 2, nrow = 2)
figure.3
```

\newpage

$Symmetric_{3,1}$


```{r, message=F, echo=F}
# Equilibrium effort: .125v per district
g4.1 <- ggplot(df, aes(x = EDG_4)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 20, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in Dark Grey: Symm_3_1")
g4.2 <- ggplot(df, aes(x = ELG_4)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 20, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in Light Grey: Symm_3_1")
g4.3 <- ggplot(df, aes(x = EW_4)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 20, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in White: Symm_3_1")

figure.4 <- ggarrange(g4.1, g4.2, g4.3,
                    labels = c("A", "B", "C"),
                    ncol = 2, nrow = 2)
figure.4
```

\newpage

Gerry_A


```{r, message=F, echo=F}
# Equilibrium effort: .25v
g5.1 <- ggplot(df, aes(x = EDG_5)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 0, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in Dark Grey: Gerry_A")
g5.2 <- ggplot(df, aes(x = ELG_5)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 0, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in Light Grey: Gerry_A")
g5.3 <- ggplot(df, aes(x = EW_5)) + 
  stat_ecdf(geom = "step") + 
  geom_vline(xintercept = 20, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) + 
  ggtitle("Bids in White: Gerry_A")

figure.5 <- ggarrange(g5.1, g5.2, g5.3,
                    labels = c("A", "B", "C"),
                    ncol = 2, nrow = 2)
figure.5
```

\newpage

Recall, Player A should pick Gerry_A and Player B should pick Gerry_B if they are choosing the map that gives them the best chance of winning.

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
stage_2 <- df %>% subset(Period > 24 & Period < 28) %>% 
  dplyr::select(Session, Subject, Period, Player, Map_Selection) %>% 
  mutate(subject.id = Session*8-(8-Subject))


library(raster)
mode_df <- stage_2 %>% group_by(subject.id, Player) %>% 
  summarise(mode.map = ifelse(length(unique(Map_Selection)) == 3, Map_Selection[3],modal(Map_Selection, ties = 'random')),
            selection.tie = ifelse(length(unique(Map_Selection)) == 3,1,0))

mode_df.v1 <- mode_df %>%
  mutate(renamed.mode.map = ifelse(mode.map==1, "Gerry_B",
                                   ifelse(mode.map==2, "Symm_1_1",
                                          ifelse(mode.map==3, "Symm_1_3",
                                                 ifelse(mode.map==4, "Symm_3_1", "Gerry_A")))))

ggplot(mode_df.v1, aes(x=renamed.mode.map)) + 
  geom_bar(width = 0.5, alpha = 0.5, position="identity") +
  geom_text(aes(label = ..count..), stat = "count", vjust = 1.5, colour = "white") +
  xlab("Map")

map_mode_bar <- ggplot(mode_df.v1, aes(x=renamed.mode.map, fill = Player, color = Player)) + 
  geom_bar(width = 0.5, alpha = 0.5, position="identity")
map_mode_bar + ggtitle("Modal Map Selection in Stage 2")

# map_mode_hist <- ggplot(mode_df, aes(x=mode.map, fill = Player, color = Player)) + 
#   geom_histogram(alpha = 0.5, position="identity")
# map_mode_hist

# sum(mode_df$mode.map == 1 & mode_df$Player == "A")
# subset(mode_df)
```

\newpage

The first figure depicts the map choices during the final stage for all participants. The second figure is of interest because we might have spillover from the previous stage whereby participants choose the map they have been choosing without really paying attention to the implications...or they could just be flipping the coin that they are the "incumbent" after randomization occurs.

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
# Create "last_period" as an empty vector and extract period 28 from each sessions
last_period <- subset(df, Period=="28")

last_period$Map_Selection <- as.character(last_period$Map_Selection)
last_period$Bug <- ifelse(last_period$Player == last_period$LType, "No", "Yes")

last_period.v1 <- last_period %>%
  mutate(renamed.map.selection = ifelse(Map_Selection==1, "Gerry_B",
                                   ifelse(Map_Selection==2, "Symm_1_1",
                                          ifelse(Map_Selection==3, "Symm_1_3",
                                                 ifelse(Map_Selection==4, "Symm_3_1",
                                                        ifelse(Map_Selection == 5, "Gerry_A", "No Selection"))))))

# Adding filter here to remove the guy who left the session while choosing a map
last_period.v1 %>% filter(renamed.map.selection != "No Selection") %>%
  ggplot(aes(x=renamed.map.selection)) +
    stat_count(width = 0.5, alpha = 0.5, position="identity") +
  geom_text(aes(label = ..count..), stat = "count", vjust = 1.5, colour = "white") +
  xlab("Map")

# Adding filter here to remove the guy who left the session while choosing a map
last_period.v1 %>% filter(renamed.map.selection != "No Selection") %>%
  ggplot(aes(x=renamed.map.selection, fill = Player, color = Player)) +
    stat_count(width = 0.5, alpha = 0.5, position="identity")+
  geom_text(aes(label = ..count..), stat = "count", vjust = 1.5, colour = "white")
```


\newpage

Now we are addressing:


1) For the map where they should be bidding on every region, I would like to see player A’s 3 CDFs overlaid on top of each other because there’s no reason for them to differ but it’s hard to tell in the version you sent. 

2) I would also like to see player B’s CDFs overlaid

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
df_clean <- df_clean %>% mutate(subject.id = as.numeric(Session)*8-(8-as.numeric(Subject)))
df_all_cdf <- df_clean %>% dplyr::select(Period, subject.id, Player, District, Map, Effort)

only.4 <- df_all_cdf %>% filter(Map == 4, District == c("EDG","ELG","EW")) # %>% group_by(subject.id, District, Effort)

ggplot(only.4, aes(x = as.numeric(Effort), size = "1")) + 
  stat_ecdf(aes(colour=District)) +
  geom_vline(xintercept = 10, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~Player) +
  ggtitle("Symm_3_1") + guides(size = F)
```


3), 4), & 5) Separately I would like to overlay player A and B’s CDFs for districts 1-3 in the map where they bid on all districts since there’s no reason for these to differ. 

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
symm.3.1.cdf.all <- ggplot(df_all_cdf %>% 
         filter(Map == 4, District == c("EDG","ELG","EW")), aes(x = as.numeric(Effort), size = "1")) +
  stat_ecdf(aes(colour=Player)) +
  geom_vline(xintercept = 10, linetype = "dashed") + xlim(0,80)+
  facet_wrap(~District)+
  #ggtitle("Symm_3_1 by District") +
  guides(size = F)
symm.3.1.cdf.all
```

\newpage


6) & 7) On each of the two maps where the players are symmetric and only bidding on one district I would like to see their CDF‘s overlaid. 

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
df_map_2 <- df_clean %>% 
  filter(Map == 2) %>% 
  dplyr::select(Period, subject.id, Player, Map, District, Effort)

df_map_3 <- df_clean %>% 
  filter(Map == 3) %>% 
  dplyr::select(Period, subject.id, Player, Map, District, Effort)

par(mfrow = c(1, 2))
# Bidding in Map 2 White District
symm.1.1.cdf <- ggplot(df_map_2 %>% filter(District == "EW"), aes(x=as.numeric(Effort), size = "1")) + 
  stat_ecdf(aes(colour=Player)) + 
  geom_vline(xintercept = 20, linetype = "dashed") + xlim(0,80)+
  #ggtitle("Symm_1_1: White District") + 
  guides(size = F)
symm.1.1.cdf
# Bidding in Map 3 White District
symm.1.3.cdf <- ggplot(df_map_3 %>% filter(District == "EW"), aes(x=as.numeric(Effort), size = "1")) + 
  stat_ecdf(aes(colour=Player)) + 
  geom_vline(xintercept = 30, linetype = "dashed") + xlim(0,80)+
  #ggtitle("Symm_1_3: White District") + 
  guides(size = F)
symm.1.3.cdf
```

\newpage

8) Overlay the CDFs of the advantage player in Gerry_B and the advantage player in Gerry_A.

9) Overlay the CDFs of the disadvantaged player in Gerry_B and the disadvantaged player in Gerry_A. 

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
dissag.df.overlay <- df_clean %>% 
  filter((Map == 1 | Map == 5) & District == "EW") %>% 
  dplyr::select(Period, subject.id, Player, Map, District, Effort) %>% 
  mutate(Advantage = ifelse((Player == "A" & Map == 5)|(Player == "B" & Map == 1), "Adv", "Dis.adv"))

par(mfrow = c(1, 2))

ggplot(dissag.df.overlay %>% filter(Advantage == "Adv"), aes(x=as.numeric(Effort), size = "1")) + 
  stat_ecdf(aes(colour=Player)) + 
  #ggtitle("Advantage Comparrison: White District") + 
  xlim(0,80)+
  geom_vline(xintercept = 20, linetype = "dashed") +
  guides(size = F)

ggplot(dissag.df.overlay %>% filter(Advantage == "Dis.adv"), aes(x=as.numeric(Effort), size = "1")) + 
  stat_ecdf(aes(colour=Player)) + 
  #ggtitle("Disadvantage Comparrison: White District") + 
  xlim(0,80)+
  geom_vline(xintercept = 20, linetype = "dashed") +
  guides(size = F)
```

\newpage

10) Assuming the two CDFs in 8) look the same and the two CDFs in 9) look the same, then make a combined advantaged CDF and a combined disadvantaged CDF and overlay those so we me can easily see how being advantaged matters.  


```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
adv.vs.disadv.cdf <- ggplot(dissag.df.overlay, aes(x=as.numeric(Effort), size = "1")) +
  scale_color_manual(values = c("black","green")) +
  stat_ecdf(aes(colour=Advantage)) +
  geom_vline(xintercept = 20, linetype = "dashed") + xlim(0,80)+
  #ggtitle("Disaggregated: Advantaged vs Disadvantaged") +
  guides(size = F) + scale_fill_brewer()
adv.vs.disadv.cdf
```

I'd like to know the average bid of advantaged players and the average bid of disadvantaged players.

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
dissag.df.overlay <- dissag.df.overlay %>%
  mutate(adv = ifelse(Advantage == "Adv",1,0),
         dis = ifelse(Advantage == "Dis.adv",1,0))

dissag.df.overlay %>% filter(adv==1) %>% summarise(mean(Effort))
dissag.df.overlay %>% filter(adv==0) %>% summarise(mean(Effort))

```
These average bids by advantaged and disadvantaged players seem odd given the difference in CDFs and the regression results below. How can we reconcile this discrepancy..?

Now let's throw together a large figure of all cdfs:
```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
library(grid)
library(gridExtra)
symm.1.1.cdf <- symm.1.1.cdf + xlab("Bid")
symm.1.3.cdf <- symm.1.3.cdf + xlab("Bid")
symm.3.1.cdf.all <- symm.3.1.cdf.all + xlab("Bid")
adv.vs.disadv.cdf <- adv.vs.disadv.cdf + xlab("Bid")
# grid.arrange(symm.1.1.cdf, symm.1.3.cdf, symm.3.1.cdf.all, adv.vs.disadv.cdf, ncol = 2)
```


*************

To be added as of 2021-04-07

[DONE]- One other small improvement to all the CDF figures would be to add a vertical line at the theoretical prediction for that map. 

[DONE]- It looks like on Symm_3_1 there is a fair amount of zero bids placed on each map. My guess is that we have lots of instances where people bid on ONLY TWO MAPS. Could you find the proportions of cases (bid tripled by a person in a period) in Symm_3_1 where the person bid 0 on all three districts (that is in a period bid 0,0,0), bid 0 on one district (so 0,x,y or x,0,y, or x,y,0 for x,y>0), bid 0 on two districts, and bid 0 on none of the districts?  My guess is that there are lots of cases where they bid 0 on one map.

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
map_four_bidding <- df %>% dplyr::select(Session, Period, Subject, Player, EDG_4, ELG_4, EW_4)

map_four_bidding <- map_four_bidding %>% mutate(two.bids = ifelse((EDG_4 > 0 & ELG_4 > 0 & EW_4 == 0)|(EDG_4 > 0 & ELG_4 == 0 & EW_4 > 0)|(EDG_4 == 0 & ELG_4 > 0 & EW_4 > 0),1,0))

map_four_bidding <- map_four_bidding %>% mutate(one.bids = ifelse((EDG_4 > 0 & ELG_4 == 0 & EW_4 == 0)|(EDG_4 == 0 & ELG_4 > 0 & EW_4 == 0)|(EDG_4 == 0 & ELG_4 == 0 & EW_4 > 0),1,0))

map_four_bidding <- map_four_bidding %>% mutate(all.three.bids = ifelse((EDG_4 > 0 & ELG_4 > 0 & EW_4 > 0),1,0))

map_four_bidding <- map_four_bidding %>% mutate(all.zeros.bids = ifelse((EDG_4 == 0 & ELG_4 == 0 & EW_4 == 0),1,0))

summarize(map_four_bidding, n.records = n(),
          n.all.zeros = sum(all.zeros.bids),
          n.one.district  = sum(one.bids),
          n.two.districts = sum(two.bids),
          n.three.districts = sum(all.three.bids),
          pct.zeros = n.all.zeros/n.records,
          pct.bid.one = n.one.district/n.records,
          pct.bid.two = n.two.districts/n.records,
          pct.bid.three = n.three.districts/n.records,
          )

```

*************

[DONE]- Look at "spread" of own bids across Symm_3_1 (max bid in any district of Symm_3_1 - min bid in any district in Symm_3_1); we'd like to see this overall (graph?) and just in the cases they bid a positive amount on everything then, for the case they only bid on 2, look at the max minus the median

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
## Took way too long to figure this out (~2 hours)
# install.packages("matrixStats")
library("matrixStats")

map_four_bidding <- map_four_bidding %>%
  mutate(districts.bid = ifelse(all.three.bids == 1, "Three", ifelse(two.bids == 1, "Two", ifelse(one.bids == 1, "One", "Zero"))),
         max_bid = pmax(EDG_4, ELG_4, EW_4),
         min_bid = pmin(EDG_4, ELG_4, EW_4),
         median_bid = rowMedians(as.matrix(map_four_bidding[,c(5,6,7)]))) # getting spread with "middle"
                                                                          # value

map_four_bidding <- map_four_bidding %>%
  mutate(Spread = ifelse(all.three.bids == 1, max_bid - min_bid, 
                         ifelse(two.bids == 1, max_bid - median_bid, 
                                ifelse(one.bids == 1, max_bid - min_bid, -1))))

map_four_bidding$districts.bid <- factor(map_four_bidding$districts.bid,                 # Re-level group factor
                         levels = c("Zero", "One", "Two", "Three"))

ggplot(map_four_bidding, aes(x=Spread, fill = districts.bid, color = districts.bid)) +
    stat_count(width = 0.5, alpha = 0.5, position="identity") + xlim(-2,80) +
  labs(title = "Unadjusted Spread",
                             subtitle = "Symm_3_1")


```

Separate graphs for bidding in two and separate for bidding in three (maybe under table with pct of Zero, One, Two, and Three bids in Symmetric_Map_3,1)

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
map_four_bidding %>% filter(districts.bid == c("Two","Three")) %>%
  ggplot(aes(x=Spread, fill = districts.bid, color = districts.bid)) +
    stat_count(width = 0.5, alpha = 0.5, position="identity") + xlim(-2,80)+ 
  facet_wrap(~districts.bid) +
  labs(y = "Count", fill = "Districts with positive bids", color = "Districts with positive bids")

```

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
## Do the pcts and the graphs treating bids =< 5 as if they are 0
# Adjusted Spread (all bids < 5 setting equal to 0)
adjusted_map_four_bidding <- df %>% dplyr::select(Session, Period, Subject, Player, EDG_4, ELG_4, EW_4)

# Replace bids <= 5 with 0
adjusted_map_four_bidding[,5:7][adjusted_map_four_bidding[,5:7] <= 5 ] <- 0

adjusted_map_four_bidding <- adjusted_map_four_bidding %>% mutate(two.bids = ifelse((EDG_4 > 0 & ELG_4 > 0 & EW_4 == 0)|(EDG_4 > 0 & ELG_4 == 0 & EW_4 > 0)|(EDG_4 == 0 & ELG_4 > 0 & EW_4 > 0),1,0))

adjusted_map_four_bidding <- adjusted_map_four_bidding %>% mutate(one.bids = ifelse((EDG_4 > 0 & ELG_4 == 0 & EW_4 == 0)|(EDG_4 == 0 & ELG_4 > 0 & EW_4 == 0)|(EDG_4 == 0 & ELG_4 == 0 & EW_4 > 0),1,0))

adjusted_map_four_bidding <- adjusted_map_four_bidding %>% mutate(all.three.bids = ifelse((EDG_4 > 0 & ELG_4 > 0 & EW_4 > 0),1,0))

adjusted_map_four_bidding <- adjusted_map_four_bidding %>% mutate(all.zeros.bids = ifelse((EDG_4 == 0 & ELG_4 == 0 & EW_4 == 0),1,0))

summarize(adjusted_map_four_bidding, n.records = n(),
          n.all.zeros = sum(all.zeros.bids),
          n.one.district  = sum(one.bids),
          n.two.districts = sum(two.bids),
          n.three.districts = sum(all.three.bids),
          pct.zeros = n.all.zeros/n.records,
          pct.bid.one = n.one.district/n.records,
          pct.bid.two = n.two.districts/n.records,
          pct.bid.three = n.three.districts/n.records,
          )

adjusted_map_four_bidding <- adjusted_map_four_bidding %>%
  mutate(districts.bid = ifelse(all.three.bids == 1, "Three", ifelse(two.bids == 1, "Two", ifelse(one.bids == 1, "One", "Zero"))),
         max_bid = pmax(EDG_4, ELG_4, EW_4),
         min_bid = pmin(EDG_4, ELG_4, EW_4),
         median_bid = rowMedians(as.matrix(adjusted_map_four_bidding[,c(5,6,7)])))

adjusted_map_four_bidding <- adjusted_map_four_bidding %>%
  mutate(Spread = ifelse(all.three.bids == 1, max_bid - min_bid, 
                         ifelse(two.bids == 1, max_bid - median_bid, 
                                ifelse(one.bids == 1, max_bid - min_bid, -1))))

adjusted_map_four_bidding$districts.bid <- factor(adjusted_map_four_bidding$districts.bid,         # Re-level group factor
                         levels = c("Zero", "One", "Two", "Three"))

ggplot(adjusted_map_four_bidding, aes(x=Spread, fill = districts.bid, color = districts.bid)) +
    stat_count(width = 0.5, alpha = 0.5, position="identity") + xlim(-2,80)+ 
  labs(title = "Adjusted Spread",
                             subtitle = "Symm_3_1")

adjusted_map_four_bidding %>% filter(districts.bid == c("Two","Three")) %>%
  ggplot(aes(x=Spread, fill = districts.bid, color = districts.bid)) +
    stat_count(width = 0.5, alpha = 0.5, position="identity") + xlim(-2,80)+ 
  facet_wrap(~districts.bid) +
  labs(title = "Adjusted Spread",
                             subtitle = "Symm_3_1")
```

[DONE]- As a first pass, we should run a K-S tests to see if the various pairs of distributions you overlaid are the same.

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
library("stats")

# Map 4 Dark Grey
EDG4A <- subset(df_all_cdf, Map == 4 & District == "EDG" & Player == "A")[,"Effort"]
EDG4B <- subset(df_all_cdf, Map == 4 & District == "EDG" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(EDG4A)),as.numeric(unlist(EDG4B)))

# Map 4 Light Grey
ELG4A <- subset(df_all_cdf, Map == 4 & District == "ELG" & Player == "A")[,"Effort"]
ELG4B <- subset(df_all_cdf, Map == 4 & District == "ELG" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(ELG4A)),as.numeric(unlist(ELG4B)))

# Map 4 White
EW4A <- subset(df_all_cdf, Map == 4 & District == "EW" & Player == "A")[,"Effort"]
EW4B <- subset(df_all_cdf, Map == 4 & District == "EW" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(EW4A)),as.numeric(unlist(EW4B)))

# Map 2 White
EW2A <- subset(df_all_cdf, Map == 2 & District == "EW" & Player == "A")[,"Effort"]
EW2B <- subset(df_all_cdf, Map == 2 & District == "EW" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(EW2A)),as.numeric(unlist(EW2B)))

# Map 3 White
EW3A <- subset(df_all_cdf, Map == 3 & District == "EW" & Player == "A")[,"Effort"]
EW3B <- subset(df_all_cdf, Map == 3 & District == "EW" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(EW3A)),as.numeric(unlist(EW3B)))

# Advantaged
ADV.A <- subset(dissag.df.overlay, Advantage == "Adv" & Player == "A")[,"Effort"]
ADV.B <- subset(dissag.df.overlay, Advantage == "Adv" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(ADV.A)),as.numeric(unlist(ADV.B)))

# Disadvantaged
Dis.ADV.A <- subset(dissag.df.overlay, Advantage == "Dis.adv" & Player == "A")[,"Effort"]
Dis.ADV.B <- subset(dissag.df.overlay, Advantage == "Dis.adv" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(Dis.ADV.A)),as.numeric(unlist(Dis.ADV.B)))

# Adv vs Dis.adv
ADV.All <- subset(dissag.df.overlay, Advantage == "Adv")[,"Effort"]
Dis.ADV.All <- subset(dissag.df.overlay, Advantage == "Dis.adv")[,"Effort"]

ks.test(as.numeric(unlist(ADV.All)),as.numeric(unlist(Dis.ADV.All)))
```


[DONE]- Also, since it seems that things are symmetric, it would be good to make a single graph that has the cdfs of total pair level investment by map (here a pair in a period is an observation). That way we can see if more is spent on some maps than others.

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
# make each pair total an observation
# gotta pull in the pEDG, pELG, pEW metrics
# total effort by pair addition to data frame
df_pair_totals <- df %>% mutate(Pair_5 = EDG_5 + pEDG_5 + ELG_5 + pELG_5 + EW_5 + pEW_5,
                                   Pair_4 = EDG_4 + pEDG_4 + ELG_4 + pELG_4 + EW_4 + pEW_4,
                                   Pair_3 = EDG_3 + pEDG_3 + ELG_3 + pELG_3 + EW_3 + pEW_3,
                                   Pair_2 = EDG_2 + pEDG_2 + ELG_2 + pELG_2 + EW_2 + pEW_2,
                                  Pair_1 = EDG_1 + pEDG_1 + ELG_1 + pELG_1 + EW_1 + pEW_1)

df_pair_totals <- df_pair_totals %>% mutate(Partner_Player = 
                                                    ifelse(Player == "B","A","B"))

long_pairs_df <- df_pair_totals %>% 
  dplyr::select(Session, Period, Subject, Player, Partner, Partner_Player, LType, Pair_5:Pair_1) %>%
  gather(District, Pair_Effort, Pair_5:Pair_1)

cleaned_pairs <- long_pairs_df %>% separate(District, c("Pairs", "Map"))
cleaned_pairs <- cleaned_pairs %>%
  mutate(renamed.map = ifelse(Map==1, "Gerry_B",
                                   ifelse(Map==2, "Symm_1_1",
                                          ifelse(Map==3, "Symm_1_3",
                                                 ifelse(Map==4, "Symm_3_1", "Gerry_A")))))

## only look at subject == c(1,2,3,4) since we'd repeat the other metrics
ggplot(cleaned_pairs %>%
         filter(Subject == c(1,2,3,4)), aes(x = as.numeric(Pair_Effort), size = "1")) +
  stat_ecdf(aes(colour = renamed.map)) + 
  xlim(0,80) +
  ggtitle("Pair Total Bidding by Map") +
  guides(size = F)
```


[DONE]- One thing that would be good to do is for each kind of choice (advantaged in map 1 or 5, disadvantaged in map 1 or 5, white in map 2, white in map 3, all regions in map 4) take the average across all subjects in a period. Then plot a time series of those averages.  This should include phase 1 and 2 so we can see if map selection impacted bidding on maps.

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
time_series_avg <- df_clean %>% 
  filter(((Map == 1 | Map == 5 | Map == 2 | Map == 3) & District == "EW")|(Map == 4)) %>% 
  dplyr::select(Session, Period, subject.id, Player, Map, District, Effort) %>% 
  mutate(Advantage = ifelse((Player == "A" & Map == 5)|(Player == "B" & Map == 1), "Adv", 
                            ifelse((Player == "B" & Map == 5)|(Player == "A" & Map == 1),"Dis.adv", "fair")),
         Choice = ifelse(Advantage == "Adv", "Adv", 
                         ifelse(Advantage == "Dis.adv", "Dis", 
                                ifelse(Map == 3, "Symm_1_3 White", 
                                       ifelse(Map == 2, "Symm_1_1 White",
                                              ifelse(Map == 4 & District == "EW", "Symm_3_1 EW",
                                                     ifelse(Map == 4 & District == "EDG", "Symm_3_1 EDG", "Symm_3_1 ELG")))))))

# Get averages for advantages in map 1 or 5, disadvantaged in map 1 or 5, white in map 2 or 3, and all districts in map 4
session.level.ts.avgs <- time_series_avg %>% filter(Period < 28, District == c("EW","EDG","ELG")) %>% 
  group_by(Session, Period, Choice) %>% summarise(avg.Effort = mean(as.numeric(Effort)))


## These time series plots are only efforts of the competitive districts. We should also look at non competitive districts to determine if a learning effect is evident.
session.level.ts.avgs %>%
  ggplot(aes(x=Period, y=avg.Effort)) +
  geom_line(aes(color = as.character(Session))) + facet_wrap(~Choice) + xlim(15,27) + ylim(0,60) +
    scale_x_continuous(breaks=c(15:27)) +
  labs(color = "Session") + ylab("Average Bid")
```
What about a time series plot with the average across all sessions?

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
time_series_avg_across_sessions <- df_clean %>% 
  filter(((Map == 1 | Map == 5 | Map == 2 | Map == 3) & District == "EW")|(Map == 4)) %>% 
  dplyr::select(Session, Period, subject.id, Player, Map, District, Effort) %>% 
  mutate(Advantage = ifelse((Player == "A" & Map == 5)|(Player == "B" & Map == 1), "Adv", 
                            ifelse((Player == "B" & Map == 5)|(Player == "A" & Map == 1),"Dis.adv", "fair")),
         Choice = ifelse(Advantage == "Adv", "Adv", 
                         ifelse(Advantage == "Dis.adv", "Dis", 
                                ifelse(Map == 3, "Symm_1_3 White", 
                                       ifelse(Map == 2, "Symm_1_1 White",
                                              ifelse(Map == 4 & District == "EW", "Symm_3_1 EW",
                                                     ifelse(Map == 4 & District == "EDG", "Symm_3_1 EDG", "Symm_3_1 ELG")))))))

# Get averages for advantages in map 1 or 5, disadvantaged in map 1 or 5, white in map 2 or 3, and all districts in map 4
session.level.ts.avgs.across.sessions <- time_series_avg_across_sessions %>% filter(Period < 28, District == c("EW","EDG","ELG")) %>% 
  group_by(Period, Choice) %>% summarise(avg.Effort = mean(as.numeric(Effort)))


## These time series plots are only efforts of the competitive districts. We should also look at non competitive districts to determine if a learning effect is evident.
ts.plot.whole.study <- session.level.ts.avgs.across.sessions %>%
  ggplot(aes(x=Period, y=avg.Effort, color = Choice)) +
  geom_line() + xlim(15,27) + ylim(0,60) +
  scale_x_continuous(breaks=c(15:27)) +
  labs(color = "Map and/or District", y = "Average Bid")
```

The following looks at the time series plots for only non-competitive districts to support our claim that a learning effect exists.

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
time_series_avg_noncompetitive <- df_clean %>% 
  filter((Map == 1 | Map == 5 | Map == 2 | Map == 3) & District == c("EDG","ELG")) %>% 
  dplyr::select(Session, Period, subject.id, Player, Map, District, Effort) %>% 
  mutate(Choice = ifelse(Map == 1 & District == "EDG", "Gerry_B EDG", 
                         ifelse(Map == 1 & District == "ELG", "Gerry_B ELG",
                                ifelse(Map == 5 & District == "EDG", "Gerry_A EDG",
                                       ifelse(Map == 5 & District == "ELG", "Gerry_A ELG",
                                              ifelse(Map == 3 & District == "EDG", "Symm_1_3 EDG",
                                                     ifelse(Map == 3 & District == "ELG", "Symm_1_3 ELG",
                                                     ifelse(Map == 2 & District == "EDG", "Symm_1_1 EDG","Symm_1_1 ELG"))))))))

# Get averages for advantages in map 1 or 5, disadvantaged in map 1 or 5, white in map 2 or 3, and all districts in map 4
session.level.ts.avgs.noncompetitive <- time_series_avg_noncompetitive %>% 
  filter(Period < 29) %>% 
  group_by(Session, Period, Choice) %>% summarise(avg.Effort = mean(as.numeric(Effort)))


## These time series plots are only efforst of the competitive districts. We should also look at non competitive districts to determine if a learning effect is evident.
session.level.ts.avgs.noncompetitive %>%
  ggplot(aes(x=Period, y=avg.Effort)) +
  geom_line(aes(color = as.character(Session))) + facet_wrap(~Choice) + xlim(15,27) + ylim(0,60) +
    scale_x_continuous(breaks=c(15:24))

time_series_avg_noncompetitive %>% 
  filter(Period < 25) %>% 
  group_by(Period, Choice) %>% summarise(avg.Effort = mean(as.numeric(Effort))) %>%
  ggplot(aes(x=Period, y=avg.Effort)) +
  geom_line() + 
  facet_wrap(~Choice) + xlim(15,27) + ylim(0,60) +
    scale_x_continuous(breaks=c(15:29))
```
NOTE: We might wish to figure out if only a few bad eggs are driving these contributions to noncompetitive districts.

[DONE]- A small cosmetic point is to make sure you keep the x-axis fixed to make comparisons between graphs easier.  It is not a big deal for this, just something to do in general. In the first part of the document you have some that include 80 and some that don’t. 

[DONE]- Average bid on each district on each map by role

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
print.data.frame(avg.bid.map.district)
```

[DONE]- Percent gerrymandering in stage 2


ISSUE: there seems to be a discrepency in how this is being calculated and it is coming from the use of "ties = 'random'" in the modal() command.

ISSUE RESOLVED
```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
mode_df$gerry <- ifelse((mode_df$Player == 'A' & mode_df$mode.map == 5)|(mode_df$Player == 'B' & mode_df$mode.map == 1),1,0)
sum(mode_df$Player == "A" & mode_df$mode.map == 1)
sum(mode_df$gerry)
pct.gerry <- sum(mode_df$gerry)/64
pct.gerry

# Figure out pct of subjects gerrymandering without including those that never converge on a map
mode_df %>% filter(selection.tie == 0) %>% 
  group_by(gerry) %>%
  summarise(count = n())
# stage_2 <- stage_2 %>% mutate(gerry = ifelse((Player == 'A' & Map_Selection == 5)|(Player == 'B' & Map_Selection == 1),1,0))
# pct.gerry.2 <- sum(stage_2$gerry)/nrow(stage_2)
# pct.gerry.2
```

[DONE]- Percentage picking each map in stage 3
```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
stage_3 <- df %>% subset(Period == 28) %>% 
  dplyr::select(Session, Subject, Period, Player, Map_Selection) %>% 
  mutate(subject.id = Session*8-(8-Subject))

by_map_selection_count <- stage_3 %>% group_by(Map_Selection) %>% tally()
by_map_selection_count$pct.of.pop <- round((by_map_selection_count$n/sum(by_map_selection_count$n))*100, 0)
print.data.frame(by_map_selection_count)
```

*************

[DONE]- Rank sum test looking at whether or not their political views influence whether they gerrymander or not...?

Before the rank sum test let's recall the PEQ relevant for the test.

PEQ_7: "On a scale of 1 to 9, how would you describe your political views with 1 being extremely liberal (i.e. to the left of the Democratic Party), 5 being centrist (i.e. falling between the Democratic Party and the Republican Party), and 9 being extremely conservative (i.e. to the right of the Republican party)." (multiple choice; 1 - 9)

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
# really just need response for each subject to include on the simplified data
# so just pull in their responses...
peq_response <- read_excel("PEQ_Responses.xlsx") %>%
  dplyr::select(Session, Period, Subject,PEQ_7,TimeSubmitPEQ7OK, PEQ_8) %>%
  mutate(subject.id = as.numeric(Session)*8-(8-as.numeric(Subject)))

# and join to gerry table
gerry_and_politics <- right_join(mode_df, peq_response, copied = F) %>%
  dplyr::select(Session, subject.id, PEQ_7, PEQ_8, gerry) %>%
  mutate(support_gerry = ifelse(PEQ_8 == 1, "Yes", "No"),
         gerry.character = ifelse(gerry == 1,"Did Gerrymander","Did not Gerrymander"))

# ggplot(transform(
#   gerry_and_politics, gerry.character=factor(gerry.character, levels=c("Did Gerrymander","Did not Gerrymander"))
#   ), 
#    aes(x = PEQ_7)) + 
#   geom_histogram(aes(fill = as.character(support_gerry))) +
#   geom_text(aes(label = ..count..), stat = "count", vjust = 1.5, size = 3, colour = "white")+
#   labs(fill = "Do you support gerrymandering?") +
#   facet_wrap(~gerry.character) + xlim(1,9) + scale_x_continuous(breaks=c(1:9)) + 
#   labs(title = "Political Leaning and Gerrymandering",
#        caption = "The left and right panels represent political self-identification \n for participants who did and did not, respectively, engage in gerrymandering through map selection. \n The coloring identifies those who stated they did or didnot support gerrymandering.")

ggplot(transform(
  gerry_and_politics, gerry.character=factor(gerry.character, levels=c("Did Gerrymander","Did not Gerrymander"))
  ), aes(x=PEQ_7, fill = as.character(support_gerry))) + 
  geom_bar(width = 0.5, alpha = 1, position="identity") +
  geom_text(aes(label = ..count..), stat = "count", vjust = 1.5, size = 3, colour = "white") +
  facet_wrap(~gerry.character) + xlim(1,9) + scale_x_continuous(breaks=c(1:9)) +
  xlab("Left to Right Political Identification") +
  labs(fill = "Do you support gerrymandering?")
       #title = "Political Leaning and Gerrymandering"
       #caption = "The left and right panels represent political self-identification \n for participants who did and did not, respectively, engage in gerrymandering through map selection. \n The coloring identifies those who stated they did or didnot support gerrymandering.")
  

ggplot(gerry_and_politics, aes(x = PEQ_7)) +
  geom_histogram(aes(fill = "PEQ_8", fill = "PEQ_8")) +
  xlim(1,9) + scale_x_continuous(breaks=c(1:9))

nrow(subset(gerry_and_politics, PEQ_7 > 5))

nrow(subset(gerry_and_politics, PEQ_7 < 5))

sum(gerry_and_politics$gerry)/nrow(gerry_and_politics)

## TO MAKE
##### stacked figure: they do gerrymandering and they don't gerrymander
```

Now, onto the rank sum test.

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
library(ggpubr)
rank_res_gerryied <- wilcox.test(PEQ_7 ~ as.character(gerry), data = gerry_and_politics,
                   exact = FALSE)
rank_res_gerryied
```

So we fail to reject the null that the political preference is the same regardless of whether they actually gerrymandered.

What about based on whether they *support* gerrymandering? (a.k.a PEQ_8)

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
rank_res_support.gerry <- wilcox.test(PEQ_7 ~ support_gerry, data = gerry_and_politics,
                   exact = FALSE)
rank_res_support.gerry
```

Also fail to reject the null that political preference is the same regardless of whether they support gerrymandering.

[DONE]- political beliefs and saying gerrymandering (**done above**; no diff. between gerrymandering and politics)

[DONE]- how either of those answers depend on whether they actually gerrymander (**above** = no diff. b/w support gerry and politics; **below** = no diff in support of gerrymandering based on whether actually gerry)

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
rank_support.gerry_actually.gerry <- wilcox.test(PEQ_8 ~ as.character(gerry), data = gerry_and_politics, exact = FALSE)
rank_support.gerry_actually.gerry

# wilcox.test(gerry ~ support_gerry, data = gerry_and_politics, exact = FALSE)
```


[DONE]- Z test of whether observations are same for number of people selecting whether they support gerrymandering or not (same # of people in both camps; probably going to be diff given the distribution between y and n)

```{r}
# Really just a two sample proportion test for proportions of Gerrymandering supporters and political leaning

```

This is a two sample t-test I believe.
(^In Sig.)



[DONE]- Of the people who say they don't support it, what % actually did it

```{r}
nrow(subset(gerry_and_politics, PEQ_8 == 2 & gerry == 1))/nrow(subset(gerry_and_politics, PEQ_8 == 2))
```



[DONE]- for the same split, did they say they like gerrymandering or not proportionately (are the proportions the same) ????????? Only have 3 that say support gerrymandering... is this enough to make any determination?

(Do you like it as a function of whether you actually did it)

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
gerry_and_politics <- gerry_and_politics %>% 
  mutate(support_gerry_numeric = ifelse(support_gerry == "No", 0, 1))

nrow(subset(gerry_and_politics, gerry == 1 & gerry_and_politics$support_gerry == "Yes"))/nrow(subset(gerry_and_politics, gerry == 1))

nrow(subset(gerry_and_politics, gerry == 0 & gerry_and_politics$support_gerry == "Yes"))/nrow(subset(gerry_and_politics, gerry == 0))
```

This is for the bar graph

  - when they don't know who they are which maps are they choosing
  - distinguish b/w people choosing gerrymandered map based on if they are choosing it after having chosen it in previous periods
  - 4 bars; gerrymander A and B on one column (two colored bars; one color is "gerrymandered for self" other color "gerrymandered for other")
  - Some people like gerrymandered maps even not knowing who they are
  - Some pick gerrymander for self (have been picking the map for themselves in previous round)
  
```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
mode_df_with_end <- inner_join(mode_df,stage_3, copied = F) %>%
  rename(final.map.choice = Map_Selection) %>%
  mutate(spillover = ifelse(mode.map == final.map.choice & gerry == 1, "Spillover", "No Spillover"))



mode_df_with_end <- mode_df_with_end[!(mode_df_with_end$final.map.choice == -99),]

mode_df_with_end <- mode_df_with_end %>%
  mutate(final.map.choice = ifelse(final.map.choice==1, "Gerry_B",
                                   ifelse(final.map.choice==2, "Symm_1_1",
                                          ifelse(final.map.choice==3, "Symm_1_3",
                                                 ifelse(final.map.choice==4, "Symm_3_1", "Gerry_A")))))

mode_df_with_end <- mode_df_with_end %>%
  mutate(mode.map = ifelse(mode.map==1, "Gerry_B",
                                   ifelse(mode.map==2, "Symm_1_1",
                                          ifelse(mode.map==3, "Symm_1_3",
                                                 ifelse(mode.map==4, "Symm_3_1", "Gerry_A")))))

#combine maps 1 and 5. Only color maps based off if they are potential spillovers
mode_df_with_end <- mode_df_with_end %>%
  mutate(adjusted.map.mode = ifelse(mode.map == 'Gerry_A' | mode.map == 'Gerry_B', "Gerry A or B", as.character(mode.map)),
         adjusted.final.map.choice = 
           ifelse(final.map.choice == "Gerry_A" | final.map.choice == "Gerry_B", "Gerry A or B", as.character(final.map.choice)))

map_mode_with_end_bar <- 
  ggplot(mode_df_with_end, aes(x=adjusted.final.map.choice, fill = spillover, color = spillover)) +
  geom_bar(width = 0.5, alpha = 0.5, position="identity")
map_mode_with_end_bar + labs(title = "Map Choice in Final Period",
                             subtitle = "Spillover includes only those who actually gerrymandered and chose their previously advantaged map both in stage 2 and stage 3")+
  geom_text(aes(label = ..count..), stat = "count", vjust = 1.5, colour = "white")
  
```


[DONE]- Regression from Deck's notes

\[Effort = \alpha + \beta_1 Player_B + \beta_2 Map_2 + \beta_3 Map_2 Player_B + \beta_4 Map_3 + \beta_5 Map_3 Player_B + \beta_6 Map_4 + \beta_7 Map_4 Player_B + \beta_8 Map_5 + \beta_9 Map_5 Player_B\]

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
#long_df <- df %>% dplyr::select(Session, Period, Subject, Player, Partner, LType, EDG_5:EW_1, pEDG_5:pEW_1) #%>% gather(District, Effort, EDG_5:pEW_1)

regress_df <- df %>% dplyr::select(Session, Period, Subject, Player, TE_1:TE_5) %>%
  filter(Period <= 24) %>%
  gather(Map, Effort, TE_1:TE_5)


regress_df <- regress_df %>% mutate(subject.id = Session*8-(8-Subject),
                                    Player_B = ifelse(Player== "B", 1, 0),
         Gerry_B = ifelse(Map == "TE_1", 1, 0),
         Symm_1_1 = ifelse(Map == "TE_2", 1, 0),
         Symm_1_3 = ifelse(Map == "TE_3", 1, 0),
         Symm_3_1 = ifelse(Map == "TE_4", 1, 0),
         Gerry_A = ifelse(Map == "TE_5", 1, 0),
         Adv = ifelse((Map == "TE_1" & Player == "B")|(Map == "TE_5" & Player == "A"), 1,0),
         Disadv = ifelse((Map == "TE_1" & Player == "A")|(Map == "TE_5" & Player == "B"), 1,0),
         Stage_2_indicator = ifelse((Period > 24 & Period < 28), 1, 0))
         
         #subject.id = Session*8-(8-Subject)


# want to use map 2 as baseline...?? Did we decide on this or not...
map.player.interaction <- lm(
  Effort ~ Player_B + Gerry_B + Gerry_B*Player_B + Symm_1_3 + Symm_1_3*Player_B + Symm_3_1 + Symm_3_1*Player_B
  + Gerry_A + Gerry_A*Player_B,
  data = regress_df
  )

summary(map.player.interaction, robust = T)
#summary(map.adv.interaction)
```

Making better tables.

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
library(stargazer)
stargazer(map.player.interaction, title = "Model 1 Regression Results", single.row = T)
```



The below tells us the role does not really matter.

```{r}
library(car)

#linearHypothesis(map.player.interaction, c("Gerry_A + Player_B:Gerry_A = 0"))
linearHypothesis(map.player.interaction, c("Player_B + Player_B:Symm_1_3 = 0")) ## in sig at 5%
linearHypothesis(map.player.interaction, c("Player_B + Player_B:Symm_3_1 = 0")) ## in sig at 5%
linearHypothesis(map.player.interaction, c("Player_B + Player_B:Symm_1_3 = 0", "Player_B + Player_B:Symm_3_1 = 0", "Player_B = 0"))

linearHypothesis(map.player.interaction, c("Player_B + Gerry_B + Player_B:Gerry_B = Gerry_A"))
linearHypothesis(map.player.interaction, c("Player_B + Gerry_A + Player_B:Gerry_A = Gerry_B"))

linearHypothesis(map.player.interaction, c(
  "Player_B + Gerry_B + Player_B:Gerry_B = Gerry_A", "Player_B + Gerry_A + Player_B:Gerry_A = Gerry_B" ,"Player_B + Player_B:Symm_1_3 = 0", "Player_B + Player_B:Symm_3_1 = 0", "Player_B = 0")
  )
```

Justified ignoring player role in comparing treatments since the joint test (that player A and B play the same) is not rejected.

```{r}
regress_df <- df %>% dplyr::select(Session, Period, Subject, Player, TE_1:TE_5) %>%
  filter(Period >= 15 & Period < 25) %>%
  gather(Map, Effort, TE_1:TE_5)


regress_df <- regress_df %>% mutate(subject.id = Session*8-(8-Subject),
                                    Player_B = ifelse(Player== "B", 1, 0),
         Gerry_B = ifelse(Map == "TE_1", 1, 0),
         Symm_1_1 = ifelse(Map == "TE_2", 1, 0),
         Symm_1_3 = ifelse(Map == "TE_3", 1, 0),
         Symm_3_1 = ifelse(Map == "TE_4", 1, 0),
         Gerry_A = ifelse(Map == "TE_5", 1, 0),
         Adv = ifelse((Map == "TE_1" & Player == "B")|(Map == "TE_5" & Player == "A"), 1,0),
         Disadv = ifelse((Map == "TE_1" & Player == "A")|(Map == "TE_5" & Player == "B"), 1,0),
         Stage_2_indicator = ifelse((Period > 24 & Period < 28), 1, 0))

map.adv.interaction <- lm(
  Effort ~ Adv + Disadv + Symm_1_3 + Symm_3_1 + Period + Adv*Period + Disadv*Period + Symm_1_3*Period + Symm_3_1*Period,
  data = regress_df
  )

summary(map.adv.interaction)
stargazer(map.adv.interaction, title = "Model 3 Regression Results", single.row = T)
```

```{r}
linearHypothesis(map.adv.interaction, c("Symm_1_3 = 10"))
linearHypothesis(map.adv.interaction, c("Symm_3_1 = 10")) # so map 4 is pushing expenditure up, but not as much as theory predicts

linearHypothesis(map.adv.interaction, c("Symm_1_3 = Symm_3_1")) # map 4 has a larger effect than map 3 even though they're predicted to have the same effect (as shown by regression, but still worth testing)

linearHypothesis(map.adv.interaction, c("Adv = Disadv"))


# testing on periods
linearHypothesis(map.adv.interaction, c("Adv:Period = 0", "Disadv:Period = 0", "Symm_1_3:Period = 0", "Symm_3_1:Period = 0", "Period = 0"))
```



[Done?]- Regression of average bid as function of period with dummy variable for Map selection phase (periods 25,26,27)


(so we just want the impact on the map selection phase on the average map level bids)

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}

## updating period to include stage 2 here

regress_df <- df %>% dplyr::select(Session, Period, Subject, Player, TE_1:TE_5) %>%
  filter(Period >= 15 & Period <= 27) %>%
  gather(Map, Effort, TE_1:TE_5)


regress_df <- regress_df %>% mutate(subject.id = Session*8-(8-Subject),
                                    Player_B = ifelse(Player== "B", 1, 0),
         Gerry_B = ifelse(Map == "TE_1", 1, 0),
         Symm_1_1 = ifelse(Map == "TE_2", 1, 0),
         Symm_1_3 = ifelse(Map == "TE_3", 1, 0),
         Symm_3_1 = ifelse(Map == "TE_4", 1, 0),
         Gerry_A = ifelse(Map == "TE_5", 1, 0),
         Adv = ifelse((Map == "TE_1" & Player == "B")|(Map == "TE_5" & Player == "A"), 1,0),
         Disadv = ifelse((Map == "TE_1" & Player == "A")|(Map == "TE_5" & Player == "B"), 1,0),
         Stage_2_indicator = ifelse((Period > 24 & Period < 28), 1, 0))

stage_2_impact <- lm(
  Effort ~ Adv + Disadv + Symm_1_3 + Symm_3_1 + Stage_2_indicator + Adv*Stage_2_indicator + Disadv*Stage_2_indicator + Symm_1_3*Stage_2_indicator + Symm_3_1*Stage_2_indicator,
  data = regress_df
  )

summary(stage_2_impact)
stargazer(stage_2_impact, title="Model 2 Regression Results", single.row = T)
```

```{r}


linearHypothesis(stage_2_impact, c("Symm_1_3 = 10"))
linearHypothesis(stage_2_impact, c("Symm_3_1 = 10"))
linearHypothesis(stage_2_impact, c("Symm_1_3 = Symm_3_1"))

linearHypothesis(stage_2_impact, c("Adv:Stage_2_indicator = 0", "Disadv:Stage_2_indicator = 0",
                                   "Symm_1_3:Stage_2_indicator = 0", "Symm_3_1:Stage_2_indicator = 0"))
```

\newpage

<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->


Redo the regressions and tests with the data from only 20 through 24 (second half of stage 1) to account for potential learning. this is because the period coefficient shows a downward trend over time.

Below are the regressions and tests using only the last 5 periods from the first stage:

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
regress_df <- df %>% dplyr::select(Session, Period, Subject, Player, TE_1:TE_5) %>%
  filter(Period >= 20 & Period <= 24) %>%
  gather(Map, Effort, TE_1:TE_5)


regress_df <- regress_df %>% mutate(subject.id = Session*8-(8-Subject),
                                    Player_B = ifelse(Player== "B", 1, 0),
         Gerry_B = ifelse(Map == "TE_1", 1, 0),
         Symm_1_1 = ifelse(Map == "TE_2", 1, 0),
         Symm_1_3 = ifelse(Map == "TE_3", 1, 0),
         Symm_3_1 = ifelse(Map == "TE_4", 1, 0),
         Gerry_A = ifelse(Map == "TE_5", 1, 0),
         Adv = ifelse((Map == "TE_1" & Player == "B")|(Map == "TE_5" & Player == "A"), 1,0),
         Disadv = ifelse((Map == "TE_1" & Player == "A")|(Map == "TE_5" & Player == "B"), 1,0),
         Stage_2_indicator = ifelse((Period > 24 & Period < 28), 1, 0))
         
map.player.interaction.adj <- lm(
  Effort ~ Player_B + Gerry_B + Gerry_B*Player_B + Symm_1_3 + Symm_1_3*Player_B + Symm_3_1 + Symm_3_1*Player_B
  + Gerry_A + Gerry_A*Player_B,
  data = regress_df
  )

summary(map.player.interaction.adj)
stargazer(map.player.interaction, map.player.interaction.adj, title = "Model 1 Regression Results", column.labels = c("w/out learning", "w/ learning"), label = "Tab:regression_1", single.row = T)
```

and the tests for this regression:

```{r}
library(car)
#linearHypothesis(map.player.interaction, c("Map_5 + Player_B:Map_5 = 0"))
linearHypothesis(map.player.interaction.adj, c("Player_B + Player_B:Symm_1_3 = 0")) ## in sig at 5%
linearHypothesis(map.player.interaction.adj, c("Player_B + Player_B:Symm_3_1 = 0")) ## in sig at 5%
linearHypothesis(map.player.interaction.adj, c("Player_B + Player_B:Symm_1_3 = 0", "Player_B + Player_B:Symm_3_1 = 0", "Player_B = 0"))

linearHypothesis(map.player.interaction.adj, c("Player_B + Gerry_B + Player_B:Gerry_B = Gerry_A"))
linearHypothesis(map.player.interaction.adj, c("Player_B + Gerry_A + Player_B:Gerry_A = Gerry_B"))

linearHypothesis(map.player.interaction.adj, c(
  "Player_B + Gerry_B + Player_B:Gerry_B = Gerry_A", "Player_B + Gerry_A + Player_B:Gerry_A = Gerry_B" ,"Player_B + Player_B:Symm_1_3 = 0", "Player_B + Player_B:Symm_3_1 = 0", "Player_B = 0")
  )
```

The above tests allow us to ignore player role given the null hypothesis that players A and B do not differ in their behavior.

That is, we can run:

```{r}
regress_df <- df %>% dplyr::select(Session, Period, Subject, Player, TE_1:TE_5) %>%
  filter(Period >= 20 & Period <= 24) %>%
  gather(Map, Effort, TE_1:TE_5)


regress_df <- regress_df %>% mutate(subject.id = Session*8-(8-Subject),
                                    Player_B = ifelse(Player== "B", 1, 0),
         Gerry_B = ifelse(Map == "TE_1", 1, 0),
         Symm_1_1 = ifelse(Map == "TE_2", 1, 0),
         Symm_1_3 = ifelse(Map == "TE_3", 1, 0),
         Symm_3_1 = ifelse(Map == "TE_4", 1, 0),
         Gerry_A = ifelse(Map == "TE_5", 1, 0),
         Adv = ifelse((Map == "TE_1" & Player == "B")|(Map == "TE_5" & Player == "A"), 1,0),
         Disadv = ifelse((Map == "TE_1" & Player == "A")|(Map == "TE_5" & Player == "B"), 1,0),
         Stage_2_indicator = ifelse((Period > 24 & Period < 28), 1, 0))

map.adv.interaction.adj <- lm(
  Effort ~ Adv + Disadv + Symm_1_3 + Symm_3_1 + Period + Adv*Period + Disadv*Period + Symm_1_3*Period + Symm_3_1*Period,
  data = regress_df
  )

summary(map.adv.interaction.adj)
stargazer(map.adv.interaction, map.adv.interaction.adj, title = "Model 3 Regression Results", column.labels = c("w/out learning", "w/ learning"), label = "Tab:regression_3", single.row = T)

```

with tests:

```{r}
linearHypothesis(map.adv.interaction.adj, c("Symm_1_3 = 10"))
linearHypothesis(map.adv.interaction.adj, c("Symm_3_1 = 10")) # so map 4 is pushing expenditure up, but not as much as theory predicts

linearHypothesis(map.adv.interaction.adj, c("Symm_1_3 = Symm_3_1")) # map 4 has a larger effect than map 3 even though they're predicted to have the same effect (as shown by regression, but still worth testing)

linearHypothesis(map.adv.interaction.adj, c("Adv = Disadv"))

# testing on periods
linearHypothesis(map.adv.interaction.adj, c("Adv:Period = 0", "Disadv:Period = 0", "Symm_1_3:Period = 0", "Symm_3_1:Period = 0", "Period = 0"))
```

Now, let's look specifically at the effect of map selection:

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}

## updating period to include stage 2 here

regress_df <- df %>% dplyr::select(Session, Period, Subject, Player, TE_1:TE_5) %>%
  filter(Period > 19 & Period <= 27) %>%
  gather(Map, Effort, TE_1:TE_5)


regress_df <- regress_df %>% mutate(subject.id = Session*8-(8-Subject),
                                    Player_B = ifelse(Player== "B", 1, 0),
         Gerry_B = ifelse(Map == "TE_1", 1, 0),
         Symm_1_1 = ifelse(Map == "TE_2", 1, 0),
         Symm_1_3 = ifelse(Map == "TE_3", 1, 0),
         Symm_3_1 = ifelse(Map == "TE_4", 1, 0),
         Gerry_A = ifelse(Map == "TE_5", 1, 0),
         Adv = ifelse((Map == "TE_1" & Player == "B")|(Map == "TE_5" & Player == "A"), 1,0),
         Disadv = ifelse((Map == "TE_1" & Player == "A")|(Map == "TE_5" & Player == "B"), 1,0),
         Stage_2_indicator = ifelse((Period > 24 & Period < 28), 1, 0))

stage_2_impact.adj <- lm(
  Effort ~ Adv + Disadv + Symm_1_3 + Symm_3_1 + Stage_2_indicator + Adv*Stage_2_indicator + Disadv*Stage_2_indicator + Symm_1_3*Stage_2_indicator + Symm_3_1*Stage_2_indicator,
  data = regress_df
  )

summary(stage_2_impact.adj)
stargazer(stage_2_impact, stage_2_impact.adj, title = "Model 2 Regression Results", column.labels = c("w/out learning", "w/ learning"), label = "Tab:regression_2", single.row = T)

```

with joint test:

```{r}
linearHypothesis(stage_2_impact.adj, c("Symm_1_3 = 10")) # can reject this
linearHypothesis(stage_2_impact.adj, c("Symm_3_1 = 10")) # can't reject this (marginally we can)
linearHypothesis(stage_2_impact.adj, c("Symm_3_1 = Symm_1_3")) # can safely reject they are the same
linearHypothesis(stage_2_impact.adj, c("Adv:Stage_2_indicator = 0", "Disadv:Stage_2_indicator = 0",
                                   "Symm_1_3:Stage_2_indicator = 0", "Symm_3_1:Stage_2_indicator = 0"))
```


\newpage


Now, we need to verify the other tests still hold with this sub-sample. We might also be interested in comparing a few tables.

To start:

```{r}
summarize(map_four_bidding, n.records = n(),
          n.all.zeros = sum(all.zeros.bids),
          n.one.district  = sum(one.bids),
          n.two.districts = sum(two.bids),
          n.three.districts = sum(all.three.bids),
          pct.zeros = n.all.zeros/n.records,
          pct.bid.one = n.one.district/n.records,
          pct.bid.two = n.two.districts/n.records,
          pct.bid.three = n.three.districts/n.records,
          )

# compared to 

summarize(subset(map_four_bidding, Period > 19), n.records = n(),
          n.all.zeros = sum(all.zeros.bids),
          n.one.district  = sum(one.bids),
          n.two.districts = sum(two.bids),
          n.three.districts = sum(all.three.bids),
          pct.zeros = n.all.zeros/n.records,
          pct.bid.one = n.one.district/n.records,
          pct.bid.two = n.two.districts/n.records,
          pct.bid.three = n.three.districts/n.records,
          )

# the above have very little difference
```

Now, the K-S tests:

```{r, warning=F, message=F, echo=F, fig.width=10, fig.height=5}
library("stats")

# Map 4 Dark Grey
EDG4A <- subset(df_all_cdf, Period > 19 & Map == 4 & District == "EDG" & Player == "A")[,"Effort"]
EDG4B <- subset(df_all_cdf, Period > 19 & Map == 4 & District == "EDG" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(EDG4A)),as.numeric(unlist(EDG4B)))

# Map 4 Light Grey
ELG4A <- subset(df_all_cdf, Period > 19 & Map == 4 & District == "ELG" & Player == "A")[,"Effort"]
ELG4B <- subset(df_all_cdf, Period > 19 & Map == 4 & District == "ELG" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(ELG4A)),as.numeric(unlist(ELG4B)))

# Map 4 White
EW4A <- subset(df_all_cdf, Period > 19 & Map == 4 & District == "EW" & Player == "A")[,"Effort"]
EW4B <- subset(df_all_cdf, Period > 19 & Map == 4 & District == "EW" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(EW4A)),as.numeric(unlist(EW4B)))

# Map 2 White
EW2A <- subset(df_all_cdf, Period > 19 & Map == 2 & District == "EW" & Player == "A")[,"Effort"]
EW2B <- subset(df_all_cdf, Period > 19 & Map == 2 & District == "EW" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(EW2A)),as.numeric(unlist(EW2B)))

# Map 3 White
EW3A <- subset(df_all_cdf, Period > 19 & Map == 3 & District == "EW" & Player == "A")[,"Effort"]
EW3B <- subset(df_all_cdf, Period > 19 &Map == 3 & District == "EW" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(EW3A)),as.numeric(unlist(EW3B)))

# Advantaged
ADV.A <- subset(dissag.df.overlay, Period > 19 & Advantage == "Adv" & Player == "A")[,"Effort"]
ADV.B <- subset(dissag.df.overlay, Period > 19 & Advantage == "Adv" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(ADV.A)),as.numeric(unlist(ADV.B)))

# Disadvantaged
Dis.ADV.A <- subset(dissag.df.overlay, Period > 19 & Advantage == "Dis.adv" & Player == "A")[,"Effort"]
Dis.ADV.B <- subset(dissag.df.overlay, Period > 19 & Advantage == "Dis.adv" & Player == "B")[,"Effort"]

ks.test(as.numeric(unlist(Dis.ADV.A)),as.numeric(unlist(Dis.ADV.B)))

# Adv vs Dis.adv
ADV.All <- subset(dissag.df.overlay, Period > 19 & Advantage == "Adv")[,"Effort"]
Dis.ADV.All <- subset(dissag.df.overlay, Period > 19 & Advantage == "Dis.adv")[,"Effort"]

ks.test(as.numeric(unlist(ADV.All)),as.numeric(unlist(Dis.ADV.All)))
```



